# Основи об'єктно-орієнтованого програмування

## Вступ

Об'єктно-орієнтоване програмування є однією з найпоширеніших парадигм розробки програмного забезпечення у сучасному світі. Розуміння принципів ООП критично важливе для створення масштабованих, підтримуваних та зрозумілих програмних систем. У цій лекції ми розглянемо фундаментальні концепції об'єктно-орієнтованого програмування, які формують основу для розробки складних програмних продуктів.

ООП дозволяє моделювати реальний світ через програмні об'єкти, що робить код більш інтуїтивним та зрозумілим. Замість того, щоб думати про програму як набір функцій та даних, ООП пропонує розглядати її як систему взаємодіючих об'єктів, кожен з яких має свої характеристики та поведінку. Такий підхід природним чином відображає структуру багатьох реальних завдань та спрощує процес проєктування складних систем.

Історія об'єктно-орієнтованого програмування починається з мови Simula у 1960-х роках, яка вперше запровадила концепцію класів та об'єктів. Пізніше ідеї ООП були розвинені в мові Smalltalk, яка повністю базувалася на об'єктно-орієнтованій парадигмі. Сьогодні переважна більшість сучасних мов програмування підтримує ООП принципи: Java, Python, C++, C#, JavaScript та багато інших. Розуміння цих принципів дозволяє розробникам ефективно працювати з різними технологіями та швидко адаптуватися до нових інструментів.

## Концепція об'єктів та класів

### Що таке об'єкт

Об'єкт у програмуванні є програмною моделлю реального або абстрактного поняття. Об'єкт поєднує в собі дані та методи для роботи з цими даними. Такий підхід називається інкапсуляцією та дозволяє об'єднати пов'язану інформацію та функціональність в єдину логічну одиницю.

Розглянемо приклад об'єкта з реального світу. Автомобіль має характеристики: колір, модель, рік випуску, пробіг. Він також має поведінку: запуск двигуна, прискорення, гальмування, поворот. В об'єктно-орієнтованому програмуванні ми можемо створити програмний об'єкт, який моделює автомобіль з усіма його характеристиками та можливостями.

```python
# Приклад об'єкта автомобіля
car = {
    'brand': 'Toyota',
    'model': 'Camry',
    'year': 2020,
    'mileage': 15000,
    'color': 'silver'
}
```

Кожен об'єкт має стан та поведінку. Стан об'єкта визначається значеннями його властивостей. В нашому прикладі стан автомобіля включає його марку, модель, рік випуску та інші характеристики. Поведінка об'єкта визначається методами, які можуть змінювати стан об'єкта або виконувати певні дії. Наприклад, метод їзди може змінювати пробіг автомобіля, а метод фарбування може змінювати колір.

Важливою особливістю об'єктів є їх ідентичність. Навіть якщо два об'єкти мають однакові характеристики, вони залишаються різними сутностями. Два автомобілі однакової моделі та кольору все одно є різними автомобілями з різною історією експлуатації. Це фундаментальна властивість об'єктів у програмуванні.

### Що таке клас

Клас є шаблоном або кресленням для створення об'єктів. Якщо об'єкт це конкретний екземпляр, то клас визначає загальну структуру та поведінку для всіх об'єктів цього типу. Використовуючи аналогію з будівництвом, клас можна порівняти з архітектурним планом будинку, а об'єкт з конкретним побудованим будинком за цим планом.

```python
# Визначення класу автомобіля
class Car:
    def __init__(self, brand, model, year, color):
        self.brand = brand
        self.model = model
        self.year = year
        self.color = color
        self.mileage = 0
        self.is_running = False

    def start_engine(self):
        if not self.is_running:
            self.is_running = True
            return f"{self.brand} {self.model}: двигун запущено"
        return f"{self.brand} {self.model}: двигун вже працює"

    def drive(self, distance):
        if self.is_running:
            self.mileage += distance
            return f"Проїхано {distance} км. Загальний пробіг: {self.mileage} км"
        return "Спершу запустіть двигун"

    def repaint(self, new_color):
        old_color = self.color
        self.color = new_color
        return f"Автомобіль перефарбовано з {old_color} на {new_color}"
```

Клас складається з двох основних компонентів: атрибутів та методів. Атрибути зберігають дані об'єкта. У нашому прикладі це марка, модель, рік випуску, колір, пробіг та стан двигуна. Методи визначають поведінку об'єктів. Метод `start_engine` запускає двигун, метод `drive` імітує їзду та збільшує пробіг, а метод `repaint` змінює колір автомобіля.

Спеціальний метод `__init__` називається конструктором та викликається автоматично при створенні нового об'єкта. Він ініціалізує початковий стан об'єкта, встановлюючи значення його атрибутів. Параметр `self` посилається на конкретний екземпляр об'єкта та використовується для доступу до його атрибутів та методів.

### Створення та використання об'єктів

Після визначення класу ми можемо створювати необмежену кількість об'єктів на його основі. Кожен об'єкт буде мати власний стан, незалежний від інших об'єктів того ж класу.

```python
# Створення екземплярів класу Car
my_car = Car('Toyota', 'Camry', 2020, 'silver')
your_car = Car('Honda', 'Civic', 2021, 'blue')

# Використання методів об'єктів
print(my_car.start_engine())
print(my_car.drive(50))
print(my_car.drive(30))

print(your_car.start_engine())
print(your_car.repaint('red'))
```

У цьому прикладі ми створили два різні об'єкти автомобілів. Хоча обидва об'єкти створені на основі одного класу `Car`, вони мають різні характеристики та незалежні стани. Зміни в одному об'єкті не впливають на інший. Коли ми збільшуємо пробіг `my_car`, пробіг `your_car` залишається незмінним.

Важливо розуміти різницю між класом та об'єктом. Клас існує один раз як шаблон, тоді як об'єктів може бути створено скільки завгодно. Кожен об'єкт займає окрему область пам'яті та має власний життєвий цикл. Об'єкти створюються під час виконання програми та знищуються, коли більше не потрібні.

## Чотири основні принципи ООП

### Інкапсуляція

Інкапсуляція є одним з найважливіших принципів об'єктно-орієнтованого програмування. Цей принцип полягає в об'єднанні даних та методів, які працюють з цими даними, в єдину структуру під назвою клас. Водночас інкапсуляція передбачає приховування внутрішньої реалізації об'єкта від зовнішнього світу.

```python
class BankAccount:
    def __init__(self, account_number, owner_name, initial_balance=0):
        self.account_number = account_number
        self.owner_name = owner_name
        self.__balance = initial_balance  # Приватний атрибут
        self.__transaction_history = []

    def deposit(self, amount):
        if amount > 0:
            self.__balance += amount
            self.__transaction_history.append(f"Поповнення: +{amount}")
            return f"Поповнено на {amount}. Новий баланс: {self.__balance}"
        return "Сума поповнення повинна бути додатною"

    def withdraw(self, amount):
        if amount > 0 and amount <= self.__balance:
            self.__balance -= amount
            self.__transaction_history.append(f"Зняття: -{amount}")
            return f"Знято {amount}. Новий баланс: {self.__balance}"
        elif amount > self.__balance:
            return "Недостатньо коштів на рахунку"
        return "Сума зняття повинна бути додатною"

    def get_balance(self):
        return self.__balance

    def get_transaction_history(self):
        return self.__transaction_history.copy()
```

У цьому прикладі атрибути `__balance` та `__transaction_history` є приватними, що позначається двома підкресленнями на початку назви. До них не можна отримати прямий доступ ззовні класу. Замість цього надаються публічні методи `deposit`, `withdraw` та `get_balance` для контрольованої взаємодії з балансом рахунку.

Переваги інкапсуляції численні та важливі для якісної розробки. По-перше, вона забезпечує захист даних від неконтрольованих змін. Ніхто не може просто встановити довільне значення балансу без використання методів класу. По-друге, інкапсуляція дозволяє змінювати внутрішню реалізацію без впливу на зовнішній код. Ми можемо змінити спосіб зберігання балансу або історії транзакцій, не змінюючи інтерфейс класу. По-третє, інкапсуляція спрощує використання класу, приховуючи складність реалізації за простим інтерфейсом методів.

Рівні доступу до членів класу визначають, хто може використовувати певні атрибути чи методи. Публічні члени доступні звідусіль та формують зовнішній інтерфейс класу. Захищені члени, які позначаються одним підкресленням, призначені для використання всередині класу та його нащадків. Приватні члени з двома підкресленнями доступні лише всередині самого класу.

```python
# Використання інкапсуляції
account = BankAccount('UA123456', 'Іван Петренко', 1000)

print(account.deposit(500))
print(account.withdraw(300))
print(f"Поточний баланс: {account.get_balance()}")

# Спроба прямого доступу до приватного атрибуту
# print(account.__balance)  # Викличе помилку AttributeError
```

### Успадкування

Успадкування дозволяє створювати нові класи на основі існуючих, успадковуючи їхні властивості та поведінку. Клас, від якого успадковується, називається батьківським класом або суперкласом. Клас, який успадковує, називається дочірнім класом або підкласом. Успадкування сприяє повторному використанню коду та створенню ієрархій класів.

```python
# Базовий клас
class Vehicle:
    def __init__(self, brand, model, year):
        self.brand = brand
        self.model = model
        self.year = year
        self.is_running = False

    def start_engine(self):
        self.is_running = True
        return f"{self.brand} {self.model}: двигун запущено"

    def stop_engine(self):
        self.is_running = False
        return f"{self.brand} {self.model}: двигун зупинено"

    def get_info(self):
        return f"{self.year} {self.brand} {self.model}"

# Дочірній клас Car успадковує Vehicle
class Car(Vehicle):
    def __init__(self, brand, model, year, num_doors):
        super().__init__(brand, model, year)
        self.num_doors = num_doors
        self.trunk_open = False

    def open_trunk(self):
        self.trunk_open = True
        return "Багажник відкрито"

    def close_trunk(self):
        self.trunk_open = False
        return "Багажник закрито"

    def get_info(self):
        base_info = super().get_info()
        return f"{base_info}, {self.num_doors} дверей"

# Дочірній клас Motorcycle успадковує Vehicle
class Motorcycle(Vehicle):
    def __init__(self, brand, model, year, engine_capacity):
        super().__init__(brand, model, year)
        self.engine_capacity = engine_capacity
        self.sidecar_attached = False

    def attach_sidecar(self):
        self.sidecar_attached = True
        return "Причеп приєднано"

    def detach_sidecar(self):
        self.sidecar_attached = False
        return "Причеп від'єднано"

    def get_info(self):
        base_info = super().get_info()
        return f"{base_info}, {self.engine_capacity}cc"
```

У цьому прикладі клас `Vehicle` є базовим класом, який визначає загальні характеристики та поведінку для всіх транспортних засобів. Класи `Car` та `Motorcycle` успадковують `Vehicle` та додають специфічну функціональність. Автомобіль має кількість дверей та багажник, мотоцикл має об'єм двигуна та можливість приєднання причепу.

Функція `super()` використовується для виклику методів батьківського класу. У конструкторах дочірніх класів ми спочатку викликаємо конструктор батьківського класу через `super().__init__()`, щоб ініціалізувати успадковані атрибути. Метод `get_info` у дочірніх класах розширює функціональність батьківського методу, додаючи специфічну інформацію.

```python
# Використання успадкування
sedan = Car('Toyota', 'Camry', 2020, 4)
bike = Motorcycle('Harley-Davidson', 'Street 750', 2019, 750)

print(sedan.get_info())
print(sedan.start_engine())
print(sedan.open_trunk())

print(bike.get_info())
print(bike.start_engine())
print(bike.attach_sidecar())
```

Типи успадкування включають одиничне успадкування, коли клас успадковує лише один батьківський клас, та множинне успадкування, коли клас успадковує декілька батьківських класів. Множинне успадкування може бути потужним інструментом, але також вносить додаткову складність та потенційні конфлікти. Багаторівневе успадкування створює ланцюжок успадкування, де клас успадковує від іншого класу, який сам є спадкоємцем.

### Поліморфізм

Поліморфізм означає можливість об'єктів різних класів реагувати на однакові повідомлення або виклики методів по-різному. Це дозволяє використовувати єдиний інтерфейс для роботи з об'єктами різних типів. Поліморфізм значно підвищує гнучкість та розширюваність коду.

```python
class Shape:
    def __init__(self, color):
        self.color = color

    def area(self):
        raise NotImplementedError("Метод area має бути реалізований у підкласі")

    def perimeter(self):
        raise NotImplementedError("Метод perimeter має бути реалізований у підкласі")

    def describe(self):
        return f"Це {self.color} фігура"

class Rectangle(Shape):
    def __init__(self, color, width, height):
        super().__init__(color)
        self.width = width
        self.height = height

    def area(self):
        return self.width * self.height

    def perimeter(self):
        return 2 * (self.width + self.height)

    def describe(self):
        return f"{super().describe()} - прямокутник {self.width}x{self.height}"

class Circle(Shape):
    def __init__(self, color, radius):
        super().__init__(color)
        self.radius = radius

    def area(self):
        return 3.14159 * self.radius ** 2

    def perimeter(self):
        return 2 * 3.14159 * self.radius

    def describe(self):
        return f"{super().describe()} - коло радіусом {self.radius}"

class Triangle(Shape):
    def __init__(self, color, side_a, side_b, side_c):
        super().__init__(color)
        self.side_a = side_a
        self.side_b = side_b
        self.side_c = side_c

    def area(self):
        s = self.perimeter() / 2
        return (s * (s - self.side_a) * (s - self.side_b) * (s - self.side_c)) ** 0.5

    def perimeter(self):
        return self.side_a + self.side_b + self.side_c

    def describe(self):
        return f"{super().describe()} - трикутник зі сторонами {self.side_a}, {self.side_b}, {self.side_c}"
```

У цьому прикладі всі фігури мають методи `area`, `perimeter` та `describe`, але кожна фігура реалізує їх по-своєму відповідно до своєї геометрії. Це дозволяє нам працювати з різними фігурами через єдиний інтерфейс.

```python
# Поліморфне використання об'єктів
shapes = [
    Rectangle('червоний', 5, 3),
    Circle('синій', 4),
    Triangle('зелений', 3, 4, 5)
]

# Обробка всіх фігур однаково
for shape in shapes:
    print(shape.describe())
    print(f"Площа: {shape.area():.2f}")
    print(f"Периметр: {shape.perimeter():.2f}")
    print()
```

Поліморфізм дозволяє писати більш загальний та гнучкий код. Функція, яка приймає параметр типу `Shape`, може працювати з будь-яким об'єктом, що успадковує цей клас, незалежно від конкретної реалізації. Це особливо корисно при розробці розширюваних систем, де нові типи об'єктів можуть додаватися без зміни існуючого коду.

Перевизначення методів є ключовим механізмом поліморфізму. Дочірній клас може надати власну реалізацію методу, успадкованого від батьківського класу. При виклику такого методу використовується версія з найбільш конкретного класу в ієрархії успадкування. Це дозволяє налаштовувати поведінку об'єктів відповідно до їхніх специфічних потреб.

### Абстракція

Абстракція означає виділення суттєвих характеристик об'єкта та ігнорування несуттєвих деталей. Абстрактні класи визначають загальний інтерфейс для групи пов'язаних класів, але не можуть бути інстанційовані безпосередньо. Вони служать шаблонами для створення конкретних класів.

```python
from abc import ABC, abstractmethod

class Database(ABC):
    def __init__(self, connection_string):
        self.connection_string = connection_string
        self.is_connected = False

    @abstractmethod
    def connect(self):
        pass

    @abstractmethod
    def disconnect(self):
        pass

    @abstractmethod
    def execute_query(self, query):
        pass

    def get_connection_status(self):
        return "Підключено" if self.is_connected else "Відключено"

class MySQLDatabase(Database):
    def connect(self):
        self.is_connected = True
        return f"Підключено до MySQL: {self.connection_string}"

    def disconnect(self):
        self.is_connected = False
        return "Відключено від MySQL"

    def execute_query(self, query):
        if not self.is_connected:
            return "Помилка: Спочатку підключіться до бази даних"
        return f"Виконано MySQL запит: {query}"

class PostgreSQLDatabase(Database):
    def connect(self):
        self.is_connected = True
        return f"Підключено до PostgreSQL: {self.connection_string}"

    def disconnect(self):
        self.is_connected = False
        return "Відключено від PostgreSQL"

    def execute_query(self, query):
        if not self.is_connected:
            return "Помилка: Спочатку підключіться до бази даних"
        return f"Виконано PostgreSQL запит: {query}"

class MongoDatabase(Database):
    def connect(self):
        self.is_connected = True
        return f"Підключено до MongoDB: {self.connection_string}"

    def disconnect(self):
        self.is_connected = False
        return "Відключено від MongoDB"

    def execute_query(self, query):
        if not self.is_connected:
            return "Помилка: Спочатку підключіться до бази даних"
        return f"Виконано MongoDB запит: {query}"
```

Абстрактний клас `Database` визначає загальний інтерфейс для роботи з базами даних, але не надає конкретної реалізації методів підключення та виконання запитів. Кожна конкретна база даних реалізує ці методи відповідно до своєї специфіки. Спроба створити екземпляр абстрактного класу призведе до помилки.

```python
# Неможливо створити екземпляр абстрактного класу
# db = Database("connection_string")  # Викличе TypeError

# Використання конкретних реалізацій
mysql_db = MySQLDatabase("localhost:3306/mydb")
postgres_db = PostgreSQLDatabase("localhost:5432/mydb")

print(mysql_db.connect())
print(mysql_db.execute_query("SELECT * FROM users"))
print(mysql_db.disconnect())

print(postgres_db.connect())
print(postgres_db.execute_query("SELECT * FROM products"))
print(postgres_db.disconnect())
```

Абстракція допомагає створювати чіткі контракти між компонентами системи. Коли ми визначаємо абстрактний клас, ми гарантуємо, що всі його нащадки матимуть певний набір методів. Це полегшує розробку модульних систем, де різні компоненти можуть взаємодіяти через добре визначені інтерфейси.

Інтерфейси та абстрактні класи служать різним цілям, хоча мають схожі функції. Абстрактний клас може містити як абстрактні методи, так і конкретну реалізацію деяких методів. Інтерфейс визначає лише сигнатури методів без реалізації. У Python різниця між ними менш виражена, ніж у деяких інших мовах, але концептуально вони служать для визначення контрактів, які повинні виконувати класи.

## Практичні аспекти ООП

### Коли використовувати ООП

Об'єктно-орієнтоване програмування найбільш ефективне у певних сценаріях. Складні додатки з багатьма взаємодіючими компонентами природним чином моделюються через об'єкти. Системи, що потребують багаторазового використання коду, виграють від успадкування та композиції. Проєкти з тривалим життєвим циклом та необхідністю підтримки потребують чіткої структури, яку надає ООП.

GUI додатки ідеально підходять для об'єктно-орієнтованого підходу. Кожен елемент інтерфейсу кнопка, текстове поле, вікно є об'єктом з властивостями та методами. Ігрова розробка також активно використовує ООП для моделювання персонажів, предметів та ігрових механік. Симуляції реального світу природним чином відображаються через об'єкти з їхньою поведінкою та взаємодією.

Для простих скриптів або утилітарних програм ООП може бути надмірним. Якщо програма складається з декількох простих функцій без складної логіки, процедурний підхід може бути ефективнішим. Важливо вибирати інструмент відповідно до завдання, а не застосовувати ООП скрізь лише тому, що це популярна парадигма.

### Переваги ООП

Модульність коду є однією з головних переваг об'єктно-орієнтованого програмування. Функціональність розділяється на окремі класи, кожен з яких відповідає за свою частину системи. Це спрощує розробку, тестування та супровід великих проєктів. Зміни в одному класі зазвичай не впливають на інші класи, що знижує ризик внесення помилок.

Повторне використання коду через успадкування та композицію значно підвищує продуктивність розробки. Замість копіювання коду між різними частинами програми, спільна функціональність виноситься в базові класи або окремі компоненти. Це не лише економить час, але й покращує підтримуваність, оскільки виправлення або покращення потрібно внести лише в одному місці.

Гнучкість та розширюваність систем досягається через поліморфізм та абстракцію. Нову функціональність можна додати шляхом створення нових класів без зміни існуючого коду. Інтерфейси дозволяють різним компонентам взаємодіяти незалежно від конкретної реалізації, що полегшує заміну або оновлення окремих частин системи.

### Недоліки та обмеження

Надмірна складність може виникнути при неправильному застосуванні ООП. Створення великої кількості класів з складними ієрархіями успадкування може зробити код важким для розуміння. Іноді простіше було б використати функції замість класів. Важливо знаходити баланс між структурованістю та простотою.

Продуктивність може страждати через додаткові рівні абстракції та накладні витрати на роботу з об'єктами. Створення та знищення великої кількості об'єктів споживає пам'ять та процесорний час. Для систем з критичними вимогами до продуктивності може знадобитися оптимізація або використання інших парадигм.

Крива навчання ООП може бути крутою для початківців. Концепції успадкування, поліморфізму та абстракції потребують часу для повного розуміння. Правильне проєктування класових ієрархій та відносин між об'єктами вимагає досвіду та практики. Помилки в проєктуванні на ранніх етапах можуть призвести до проблем у майбутньому.

## Найкращі практики ООП

### Принципи проєктування класів

Кожен клас повинен мати чітку відповідальність та робити одну річ добре. Це принцип єдиної відповідальності, про який ми детальніше поговоримо в наступній лекції. Клас не повинен бути занадто великим або намагатися виконувати занадто багато різних завдань. Якщо клас стає надто складним, варто розглянути можливість розділення його на декілька менших класів.

Інкапсуляція повинна дотримуватися послідовно. Внутрішні деталі реалізації класу мають бути приховані від зовнішнього світу. Взаємодія з об'єктами повинна відбуватися через добре визначений публічний інтерфейс. Це дозволяє змінювати внутрішню реалізацію без впливу на код, що використовує клас.

Успадкування слід використовувати обережно. Замість глибоких ієрархій успадкування часто краще використовувати композицію. Принцип "композиція над успадкуванням" рекомендує будувати функціональність через об'єднання об'єктів замість створення складних ієрархій класів. Успадкування найкраще підходить для моделювання відносин "є", тоді як композиція для відносин "має".

### Іменування та організація коду

Назви класів мають бути іменниками, що відображають суть об'єкта. Використовуйте PascalCase для назв класів у більшості мов програмування. Назви повинні бути описовими та зрозумілими без необхідності читати документацію. Уникайте загальних назв як `Manager`, `Handler` або `Utility`, якщо можна знайти більш конкретну назву.

Методи класу повинні мати назви, що починаються з дієслів, оскільки вони виконують дії. Використовуйте snake_case у Python або camelCase в інших мовах. Параметри методів повинні мати описові назви, які пояснюють їхнє призначення. Приватні атрибути та методи позначайте відповідним префіксом, щоб показати, що вони призначені для внутрішнього використання.

Організація файлів та модулів важлива для підтримки великих проєктів. Зазвичай кожен клас розміщується в окремому файлі, особливо якщо клас великий. Пов'язані класи можна групувати в модулі або пакети. Чітка структура директорій полегшує навігацію в проєкті та пошук потрібного коду.

### Документування коду

Кожен клас повинен мати docstring, що описує його призначення та відповідальність. Документація має пояснювати, що робить клас, а не як він це робить. Опишіть основні атрибути класу та їхнє призначення. Вкажіть приклади використання класу для кращого розуміння.

```python
class ShoppingCart:
    """
    Клас для управління кошиком покупок в інтернет-магазині.

    Attributes:
        items (list): Список товарів у кошику
        customer_id (str): Ідентифікатор покупця

    Example:
        cart = ShoppingCart('CUST123')
        cart.add_item('Laptop', 1200, 1)
        total = cart.get_total()
    """

    def __init__(self, customer_id):
        """
        Ініціалізує новий кошик для покупця.

        Args:
            customer_id (str): Унікальний ідентифікатор покупця
        """
        self.customer_id = customer_id
        self.items = []

    def add_item(self, name, price, quantity=1):
        """
        Додає товар до кошика.

        Args:
            name (str): Назва товару
            price (float): Ціна за одиницю товару
            quantity (int): Кількість одиниць товару

        Returns:
            dict: Доданий товар з усіма деталями
        """
        item = {
            'name': name,
            'price': price,
            'quantity': quantity,
            'total': price * quantity
        }
        self.items.append(item)
        return item
```

Методи класу також потребують документації, особливо якщо вони є частиною публічного інтерфейсу. Опишіть параметри методу, що він повертає та які винятки може генерувати. Якщо метод має побічні ефекти або змінює стан об'єкта, це варто зазначити в документації.

## Висновки

Об'єктно-орієнтоване програмування є потужною парадигмою, яка дозволяє створювати структуровані, підтримувані та масштабовані програмні системи. Розуміння чотирьох основних принципів ООП інкапсуляції, успадкування, поліморфізму та абстракції є фундаментом для ефективного використання цього підходу.

Класи та об'єкти надають природний спосіб моделювання реального світу в коді. Правильне використання інкапсуляції захищає дані та приховує складність реалізації. Успадкування дозволяє повторно використовувати код та створювати логічні ієрархії. Поліморфізм надає гнучкість у роботі з різними типами об'єктів через єдиний інтерфейс. Абстракція допомагає визначати чіткі контракти між компонентами системи.

Застосування найкращих практик ООП включає дотримання принципів проєктування, правильне іменування та організацію коду, а також ретельне документування. Важливо пам'ятати, що ООП це інструмент, який слід використовувати доречно. Не кожна задача потребує об'єктно-орієнтованого підходу, і вміння обирати правильну парадигму для конкретної ситуації є ознакою досвідченого розробника.

У наступних лекціях ми детальніше розглянемо принципи проєктування програмного забезпечення та архітектурні патерни, які базуються на концепціях ООП та дозволяють створювати ще більш якісні програмні системи.

## Питання для самоперевірки

1. У чому різниця між класом та об'єктом? Наведіть приклад з реального життя.
2. Поясніть принцип інкапсуляції та чому він важливий для розробки програмного забезпечення.
3. Які переваги надає успадкування? У яких ситуаціях краще використовувати композицію замість успадкування?
4. Що таке поліморфізм та як він реалізується в об'єктно-орієнтованому програмуванні?
5. Яка різниця між абстрактним класом та звичайним класом?
6. Які основні переваги та недоліки об'єктно-орієнтованого програмування?
